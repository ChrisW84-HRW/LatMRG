<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatMRG Guide: Theory of Random Numbers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LatMRG Guide
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A software package to test and search for new linear congruential random number generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('background.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Theory of Random Numbers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page covers the theory specific to <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> in two main sections and a third secondary one.</p>
<p>First, we present all the generators engines covered by the library. Along with the generators definitions, we present the equivalences that make it possible to study all those generatorse in <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a>. In the second section, we present the construction of lattices for such random generators, as well as the computations to study such lattices. In the last section, we present some issues arrising when choosing parameters for a generator. This is an optionnal section that can be helpfull when starting searches with <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a>.</p>
<h1><a class="anchor" id="back_gen"></a>
Linear Congruential Engines</h1>
<h2><a class="anchor" id="back_gen_gen"></a>
Simple Congruential Generators</h2>
<p>We assume some familiarity with the concept of random number generator from from the reader. If this is not the case, we recommend reading the beginning of <a class="el" href="citelist.html#CITEREF_rLEC17h">[37]</a>. Although this is not the shortest introduction to random number generators, it is very well suited for beginners and it covers both historical and modern issues of random number generation.</p>
<p>We first present the oldest and simplest generator engine that <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> covers. Given \(a,m,c \in \mathbb{Z}\), usually also with the constraints \(0 &lt; a &lt; m\) and \(0 \leq c &lt; m,\ 1 \equiv c \pmod 2\), we can get pseudo-random number in \((0,1)\) by generating the sequence \(\{x_n\}\) </p><p class="formulaDsp">
\[ x_n = a x_{n-1} + c \pmod m \]
</p>
<p> and by taking the output of \(u_n = x_n / m\). Note that if \(c = 0\), the components also need to be such that \(\gcd(a,m) = 1\).</p>
<p>This kind of generator is called a <b>linear congruential generator</b> LCG. It is easy to implement and runs fast. But as computing power grew, It became clear that it was not practical to have a LCG as a random number generator. These generator have a high correlation between their points. It is also impractical to make on with a long enough period as the maximal possible period for a LCG is \(m-1\).</p>
<p>The natural extension of this engine that arose was the augmentation of the order of the recurrence as follows: </p><p class="formulaDsp">
\[ x_n = a_1 x_{n-1} + \cdots + a_k x_{n-k} \pmod m \]
</p>
<p> where \(a_k \neq 0\). This engine can output random numbers in the same way by taking \(u_n = x_n / m\). Using this kind of recurrence mostly solves the problems of LCGs as it increases the states space considerably. This kind of engine is called a <b>multiple recursive generator</b> (MRG). Note that LCG generators simply are a specific case of MRG generators. It turns out that most of the generators presented after this point are equivalent to a MRG in some way and can be considered simply as MRGs when developping the theory. This is for this reason that this software is called <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a>. <a class="el" href="background.html#back_other">Lattices and Merit</a> presents the main results to study a MRG, but they also have been broadly studied in the litterature in, for example, <a class="el" href="citelist.html#CITEREF_rLEC93a">[28]</a> <a class="el" href="citelist.html#CITEREF_rLEC88a">[29]</a>, and <a class="el" href="citelist.html#CITEREF_rLEC97b">[33]</a>.</p>
<h2><a class="anchor" id="back_gen_carry"></a>
Carry Generators</h2>
<p>Using a MRG is much slower that using a LCG so many avenues have been studied as a way to generate random numbers on a period large enough to be useable, but that is faster than an MRG. This is what <a class="el" href="citelist.html#CITEREF_rMAR91a">[39]</a> introduced. These engines are fast and also have long periods and use the following recurrences with \(r &gt; s\) and \(b \in \mathbb{Z}_{&gt;0}\): </p><p class="formulaDsp">
\[ \begin{array}{llll} \text{(AWC)} &amp; x_n &amp; = &amp; x_{n-s} + x_{n-r} + c_n \pmod b, \\ &amp; c_{n+1} &amp; = &amp; \mathbb{1}(x_{n-s} + x_{i-r} + c_n \geq b). \\ \text{(AWC-c)} &amp; x_n &amp; = &amp; -x_{n-s} - x_{n-r} - c_n - 1 \pmod b,\\ &amp; c_{n+1} &amp; = &amp; \mathbb{1}(x_{n-s} + x_{i-r} + c_n \geq b).\\ \text{(SWB-I)} &amp; x_n &amp; = &amp; x_{n-s} - x_{n-r} - c_n \pmod b,\\ &amp; c_{n+1} &amp; = &amp; \mathbb{1}(x_{n-s} - x_{n-r} - c_n &lt; 0).\\ \text{(SWB-II)} &amp; x_n &amp; = &amp; - x_{n-s} + x_{n-r} - c_n \pmod b,\\ &amp; c_{n+1} &amp; = &amp; \mathbb{1}(x_{n-s} - x_{n-r} - c_n &lt; 0).\\ \end{array} \]
</p>
<p> These generators are called Add-with-Carry (AWC) and Subtract-with-Borrow (SWB) (we follow the naming scheme of <a class="el" href="citelist.html#CITEREF_rTEZ93a">[52]</a> for the variants). The fact that these generators do not need multiplication operations mean that they will be very fast with b as a power of 2. With a good choice of parameters, the period of the recurrence can be up to around \(b^r\), which means that this generator solves both the period length problem and the speed one.</p>
<p>The sequence \(\{x_n\}\) can be used to generate random \(\mathcal{U}(0,1)\) numbers with an arbitrary number of digits in base \(b\) with </p><p class="formulaDsp">
\[ u_n = \sum_{j=1}^L x_{Ln + j + 1} b^{-j}. \]
</p>
<p> By taking \(M\) as follows, </p><center> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Generator  </th><th class="markdownTableHeadCenter">M   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">AWC  </td><td class="markdownTableBodyCenter">\(b^r+b^s-1\)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">AWC-c  </td><td class="markdownTableBodyCenter">\(b^r+b^s+1\)   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">SWB-I  </td><td class="markdownTableBodyCenter">\(b^r-b^s+1\)   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">SWB-II  </td><td class="markdownTableBodyCenter">\(b^r-b^s-1\)   </td></tr>
</table>
</center><p> We can build an equivalence between AWC/SWB generators and the following LCG (<a class="el" href="citelist.html#CITEREF_rTEZ93a">[52]</a>) </p><p class="formulaDsp">
\begin{align} X_n &amp; = AX_{n-1} \pmod M \\ v_n &amp; = X_n / M \\ w_n &amp; = X_{Ln}/M. \end{align}
</p>
<p> When we say equivalence, this is in the sense that, with the right initial state, the output \(w_i\) and \(u_i\) have the same decimal digits in base \(b\) up to the precision of \(u_i\). That is: \(u_i = b^{-L} \lfloor b^L w_i \rfloor\).</p>
<p>It turns out that AWC/SWB generators have a few faults in theoretical tests. <a class="el" href="citelist.html#CITEREF_rMAR94a">[41]</a> suggested a similar kind of recurrence to solve this issue called <b>multiply-with-carry</b> (MWC) </p><p class="formulaDsp">
\[ \begin{array}{lll} x_n &amp; = &amp; (a_1 x_{n-1} + \cdots + a_k x_{n-k} + c_{n-1})d \pmod b,\\ c_n &amp; = &amp; \lfloor (a_0 x_n + a_1 x_{n-1} + \cdots + a_k x_{n-k})/b\rfloor, \end{array} \]
</p>
<p> where \(\gcd(a_0, b) = 1\) and \(1 \equiv -a_0d \pmod b\). This engine uses the same output function as AWC/SWB generators \( u_n = \sum_{j=1}^L x_{Ln + j + 1} b^{-j} \) and the results of <a class="el" href="citelist.html#CITEREF_rTEZ93a">[52]</a> can be tweaked as in <a class="el" href="citelist.html#CITEREF_rCOU97a">[9]</a>. Take \(M = \sum_{l = 0}^k a_k b^l\) and \(0 &lt; A &lt; m\) with \(1 \equiv Ab \pmod m\), then the same recurrence </p><p class="formulaDsp">
\begin{align} X_n &amp; = AX_{n-1} \pmod M \\ v_n &amp; = X_n / M \\ w_n &amp; = X_{Ln}/M. \end{align}
</p>
<p> is equivalent to the MWC generator with the same precision: \(u_i = b^{-L} \lfloor b^L w_i \rfloor\).</p>
<h2><a class="anchor" id="back_gen_comb"></a>
Combined Generators</h2>
<p>Generators using a carry can easily be constructed to have a large period and to operate very fast, but the fact that they are equivalent to LCGs means that their structure is most of the time flawed, especially in 2 dimensions. To solve this problem, it was suggested to use multiple MRGs and to combine their output. This reduces the computing cost of big MRGs, while obtaining much better distribution than carry generators.</p>
<p>Let sequences \(\{\{x_n^{(1)}\},\{x_n^{(2)}\},\ldots,\{x_n^{(\ell)}\}\}\) and \(\{\{u_n^{(1)}\},\{u_n^{(2)}\},\ldots,\{u_n^{(\ell)}\}\}\) be produced by MRGs with \(a_{i,j}\) the j-th coefficient of the i-th recurrence, \(k_i\) the order of the i-th recurrence and \(m_i\) the modulus of the i-th recurrence. It is possible to get pseudo-random numbers as: </p><p class="formulaDsp">
\[ \begin{array}{lll} \tilde{u}_n &amp; = &amp; \left(\sum_{i = 1}^\ell \delta_{i} x_n^{(i)} \pmod {m_1} \right) / m_1 \\ w_n &amp; = &amp; \sum_{i = 1}^\ell \frac{\delta_{i} x^{(i)}_n}{m_i} \pmod 1. \end{array} \]
</p>
<p><a class="el" href="citelist.html#CITEREF_rLEC96b">[32]</a> presents a way to build a MRG that has an output \(\{u_n\}\) identical to \(\{w_n\}\) if their first \(k = \max(k_1, \ldots, k_\ell)\) output values are the same. Define </p><p class="formulaDsp">
\begin{align} m &amp; = \prod_{i = 1}^\ell m_i \\ b &amp; = \sum_{i=1}^\ell \frac{\delta_i b_i m}{m_i} \pmod m \\ n_j &amp; \text{with } 1 \equiv n_j (m /m_j) \pmod {m_j},\ 1 \leq j \leq \ell \\ a_j &amp; = \sum_{i=1}^\ell \frac{a_{i,j} n_i m}{m_i} \pmod m,\ 1 \leq j \leq k. \end{align}
</p>
<p> Then if \((u_0, \ldots, u_{k-1}) = (w_0, \ldots, w_{k-1})\), then \(w_n = u_n\) for all \(n\in\mathbb{N}\) given </p><p class="formulaDsp">
\begin{align} x_n &amp; = a_1 x_{n-1} + \cdots + a_k x_{n-k} + b \pmod m \\ u_n &amp; = x_n/m. \end{align}
</p>
<h2><a class="anchor" id="back_gen_mat"></a>
Matrix Generators</h2>
<p>The final type of generator that we present is slightly different. This is because it cannot be transformed to an equivalent MRG. Instead, this is a generalization of an MRG.</p>
<p>Take \(\mathbf{A}\in \mathbb{Z}^{k\times k}\) and \(s_n \in \mathbb{Z}^k\). We can generate a random number vector with </p><p class="formulaDsp">
\[ s_n = \mathbf{A} s_{n-1} \pmod m \]
</p>
<p> and \(\mathbf{u}_n = (1/m) \cdot s_n\). This is what we call a <b>matrix multiple recursive generator</b> (MMRG). This kind of generator can also be used to generate any size of vector, including single random numbers. Let \(\mathbf{u}_n(i)\) be the i-th component for vector \(\mathbf{u}_n\) and \(p = qk + r,\ 0 \leq r &lt; k\) be the size of vectors wanted. We can get the random vector sequence \(\{v_n = (\mathbf{u}_{n(q+1)}(1), \ldots, \mathbf{u}_{n(q+1)}(k), \ldots, \mathbf{u}_{n(q+1)+q}(1), \ldots, \mathbf{u}_{n(q+1)+q}(r)) \in \mathbb{Z}^p\}\).</p>
<p>We will see below that a MRG of order \(k\) with multipliers \((a_1, \ldots, a_k)\) and modulo \(m\) has the same output structure as a MMRG with </p><p class="formulaDsp">
\[ \mathbf{A} = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; \cdots &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; \ddots &amp; 0 \\ \vdots &amp; &amp; \ddots &amp; \ddots &amp; \vdots \\ 0 &amp; \cdots &amp; \cdots &amp; 0 &amp; 1 \\ a_1 &amp; a_2 &amp; \cdots &amp; \cdots &amp; a_k \end{bmatrix}^k \]
</p>
<h1><a class="anchor" id="back_other"></a>
Lattices and Merit</h1>
<p>As explained in <a class="el" href="lattice_back.html">Theory on Lattices</a>, lattices of dimension \(t\) are discrete subgroups of \(\mathbb{R}^t\) generated by the integer combinations of a set of linearly independant (over the integers) vectors.</p>
<h2><a class="anchor" id="back_lat"></a>
Lattice of a MRG</h2>
<h2><a class="anchor" id="back_merit"></a>
Measures on MRGs</h2>
<h3><a class="anchor" id="back_merit_per"></a>
Period Length</h3>
<h3><a class="anchor" id="back_merit_spectral"></a>
Shortest Vector and Figures of Merit</h3>
<h1><a class="anchor" id="back_param"></a>
A Good Parameter Choice</h1>
<p>A random number generator uses some kind of hashing function to generate apparent (but not true) randomness in its next state. The generators covered by <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> all share the same kind of transformation and this is what makes them similar. All of the generators covered here use a linear recurrence, meaning we apply a linear transformation on the previous state(s) of the generator, followed by a modulo operation as a hash.</p>
<p>The choice of modulo is a recurrent source of discussion when building such generators. This is because a modulo operation takes a variable time for variable modulus. Most of the time, there is a compromise to do between simple modulus like \(2^q\) (which can be computed with a simple xor operation) and \(p\) big prime number. The former is much faster to compute, but the latter usually performs much better in theoretical and statistical tests.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>The file still contains the old background, but this should be rethought and redone from the ground up. This should probably be stored in a pdf file shipped with <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a>.</dd></dl>
<p><a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> is a software system implemented as a library of classes written in the C++ language.</p>
<p>It provides different tools for studying the structure of lattices in the real space and for examining the theoretical properties of random number generators based on linear recurrences in modular arithmetic or the properties of integration lattices (for now, Korobov and rank 1 lattices). It offers facilities for checking if a generator has maximal period or not, for examining its lattice structure (e.g., applying lattice and spectral tests), and for performing computer searches for "good" generators according to different quality criteria. The software can also be used for related applications, such as searching and evaluating lattice rules for quasi-Monte Carlo integration.</p>
<p>In this section, we give a quick recall of some definitions and notation, as well as a short outline of what the package does. For more details on the underlying theory and algorithms, see <a class="el" href="citelist.html#CITEREF_rCOU96x">[7]</a>, <a class="el" href="citelist.html#CITEREF_rLEC94e">[26]</a> and other references given there. We classify the modules of <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> in three groups: (a) low-level, (b) intermediate-level, and (c) high-level. Higher-level programs import facilities from the lower-level ones.</p>
<p>The high-level modules (c) are programs in executable form which read their data from files. They can either analyze a given generator or seek "good" generators according to different criteria. Examples of data files and results are given in Section 2. Appendix A gives specifications of the data file formats and of what the programs do.</p>
<p>The intermediate-level classes (b) provide data types and methods to construct lattice bases for different classes of generators (simple or combined MRGs, lacunary indices, etc.), manipulate such bases, find a shortest vector in a lattice, reduce a basis in the sense of Minkowski, and so on. These tools are used by the upper-level programs (c), but can also be used directly to make programs different than those already provided at level (c), offering thus more flexibility. The lower-level classes (a) implement basic operations on scalars, vectors, matrices, polynomials, and so on. They allow different possible representations for these objects, depending, for example, on the size of the modulus \(m\) and the precision we want, as explained in Section 1.6. These lower-level tools are used by the modules of levels (b) and (c). The intermediate and low-level classes are discussed a little further in Section 3, and their specifications are given in appendices B and C.</p>
<h1>Lattices in the real space</h1>
<p>The <em>lattices</em> considered here are discrete subspaces of the real space \(\mathbb R^t\), which can be expressed as </p><p class="formulaDsp">
\[ L_t = \left\{\mathbf{v}= \sum_{j=1}^t z_j\mathbf{v}_j\mid\mbox{ each } z_j\in\mathbb{Z}\right\}, \tag{lattice} \]
</p>
<p> where \(t\) is a positive integer, and \(\mathbf{v}_1,…,\mathbf{v}_t\) are linearly independent vectors in \(\mathbb R^t\) which form a <em>basis</em> of the lattice. A comprehensive treatment of such lattices can be found in <a class="el" href="citelist.html#CITEREF_mCON99a">[5]</a>. The matrix \(\mathbf{V}\), whose \(i\)th line is \(\mathbf{v}_i\), is the corresponding <em>generator matrix</em> of \(L_t\). A lattice \(L_t\) shifted by a constant vector \(\mathbf{v}_0\not L_t\), i.e., a point set of the form \(L’_t = \{\mathbf{v}+\mathbf{v}_0 : \mathbf{v}\in L_t\}\), is called a <em>grid</em>, or a <em>shifted lattice</em>. The lattices considered in this guide always contain, or are contained in, the integer lattice \(\mathbb{Z}^t\), i.e., \(\mathbb{Z}^t\subseteq L_t\) or \(L_t\subseteq\mathbb{Z}^t\).</p>
<p>The <em>dual lattice</em> of \(L_t\) is defined as \(L_t^* = \{\mathbf{h}\in\mathbb R^t \mid\mathbf{h}\cdot\mathbf{v}\in\mathbb{Z}\) for all \(\mathbf{v}\in L_t\}\). The <em>dual</em> of a given basis \(\mathbf{v}_1,…,\mathbf{v}_t\) is the set of vectors \(\mathbf{w}_1,…,\mathbf{w}_t\) in \(\mathbb R^t\) such that \(\mathbf{v}_i\cdot\mathbf{w}_j = \delta_{ij}\), where \(\delta_{ij}=1\) if \(i=j\), and \(\delta_{ij}=0\) otherwise. It forms a basis of the dual lattice. These \(\mathbf{w}_j\)’s are the columns of the matrix \(\mathbf{V}^{-1}\), the inverse of the matrix \(\mathbf{V}\). If \(m\) is any positive real number, a basis \(\{\mathbf{w}_1,…,\mathbf{w}_t\}\) satisfying \(\mathbf{v}’_i \mathbf{w}_j = \delta_{ij} m\) for all \(i\), \(j\) is called the \(m\)-dual of the basis \(\{\mathbf{v}_1,…,\mathbf{v}_t\}\). The lattice generated by this \(m\)-dual basis is the \(m\)-dual to \(L\). This extension of the usual notion of dual basis and dual lattice will allow us, by a suitable choice of \(m\) [in our context it will be the modulus in , to deal uniquely with integer coordinate vectors, which can be represented exactly on a computer.</p>
<p>The determinant of the matrix \(\mathbf{V}\) is equal to the volume of the fundamental parallelepiped \(\Lambda= \{\mathbf{v}= \lambda_1\mathbf{v}_1 + \cdots+ \lambda_t\mathbf{v}_t \mid0\le\lambda_i\le1\) for \(1\le i\le t\}\), and is also the inverse of the average number of points per unit of volume, independently of the choice of basis. It is called the determinant of \(L_t\). The quantity \(1/\det(L_t) = 1/\det(\mathbf{V}) = \det(\mathbf{V}^{-1})\) is called the <em>density</em> of \(L_t\). When \(L_t\) contains \(\mathbb{Z}^t\), the density is an integer equal to the cardinality of the point set \(L_t \cap[0,1)^t\).</p>
<p>For a given lattice \(L_t\) and a subset of coordinates \(I = \{i_1,…,i_d\} \subseteq\{1,…,t\}\), denote by \(L_t(I)\) the projection of \(L_t\) over the \(d\)-dimensional subspace determined by the coordinates in \(I\). This projection is also a lattice, whose density divides that of \(L_t\). There are exactly \(\det(L_t(I))/\det(L_t)\) points of \(L_t\) that are projected onto each point of \(L_t(I)\). In group theory language, \(L_t(I)\) corresponds to a coset of \(L_t\).</p>
<h1>Multiple recursive generators</h1>
<p>Consider the linear recurrence </p><p class="formulaDsp">
\[ x_n = (a_1 x_{n-1} + \cdots+ a_k x_{n-k}) \mod m. \tag{recurs} \]
</p>
<p> where \(m\) and \(k\) are positive integers and each \(a_i\) belongs to the set (or ring) \(\mathbb{Z}_m = \{0,1,…,m-1\}\). For \(n\ge0\), \(s_n = (x_n,…,x_{n+k-1}) \in\mathbb{Z}_m^k\) is the <em>state</em> at step \(n\). The initial state \(s_0\) is called the <em>seed</em>. One can take \(u_n = x_n/m \in[0,1)\) as the <em>output</em> at step \(n\). This kind of generator is called <em>multiple recursive</em> (MRG). When \(k=1\), it gives the well-known multiplicative linear congruential generator (MLCG). MLCGs in <em>matrix form</em> can also be expressed as many copies of the same MRG running in parallel. For more details, see <a class="el" href="citelist.html#CITEREF_rGRO88a">[16]</a>, <a class="el" href="citelist.html#CITEREF_rLEC90a">[30]</a>, <a class="el" href="citelist.html#CITEREF_rLEC94a">[31]</a>, <a class="el" href="citelist.html#CITEREF_rNIE86a">[43]</a>.</p>
<p>The maximal possible period for the \(s_n\)’s is the cardinality of \(\mathbb{Z}_m^t\) minus 1, i.e. \(\rho= m^k-1\). It is attained if and only if \(m\) is prime and the characteristic polynomial of , </p><p class="formulaDsp">
\[ P(z) = \left(z^k - \sum_{i=1}^k a_i z^{k-i}\right) \mod m, \]
</p>
<p> is a primitive polynomial modulo \(m\). Knuth <a class="el" href="citelist.html#CITEREF_rKNU97a">[23]</a> gives necessary and sufficient conditions for that, which are implemented in our package. If \(k=1\) and \(m=p^e\), with \(e &gt; 1\), then the maximal possible period is \(2^{e-2}\) for \(p=2\) and \((p-1)p^{e-1}\) for \(p &gt; 2\) <a class="el" href="citelist.html#CITEREF_rKNU97a">[23]</a>, <a class="el" href="citelist.html#CITEREF_rLEC90a">[30]</a>.</p>
<p>Instead of taking \(u_n = x_n/m\) for the output, one can take a more general linear combination of the components of the state vector, say </p><p class="formulaDsp">
\begin{align} y_n &amp; = (b_1 x_n + \cdots+ b_k x_{n+k-1}) \mod m, \tag{yn} \\ u_n &amp; = y_n /m. \tag{output2} \end{align}
</p>
<p> For any integer \(t\ge1\), one has </p><p class="formulaDsp">
\[ \begin{pmatrix} y_n \\ y_{n+1} \\ \vdots \\ y_{n+t-1} \end{pmatrix} = \begin{pmatrix} \mathbf{b}’ \\ \mathbf{b}’\mathbf{A} \\ \vdots \\ \mathbf{b}’\mathbf{A}^{t-1} \end{pmatrix} \begin{pmatrix} x_n \\ x_{n+1} \\ \vdots \\ x_{n+k-1} \end{pmatrix} \; \mod m =: \mathbf{B}_t \begin{pmatrix} x_n \\ x_{n+1} \\ \vdots \\ x_{n+k-1} \end{pmatrix} \; \mod m, \tag{tpoly} \]
</p>
<p> where \(\mathbf{b}’ = (b_1,…,b_k)\) and </p><p class="formulaDsp">
\[ A = \begin{pmatrix} 0 &amp; 1 &amp; … &amp; 0 \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; … &amp; 1 \\ a_k &amp; a_{k-1} &amp; … &amp; a_1 \end{pmatrix} \tag{companion} \]
</p>
<p> is the <em>companion matrix</em> of the characteristic polynomial \(P(z)\). In particular, by taking \(t=k\), one sees that the vector \((y_n,…,y_{n+k-1})\) takes all possible values in \(\mathbb{Z}_m^k\), when \((x_n,…,x_{n+k-1})\) does so, if and only if the matrix \(\mathbf{B}_k\) has full rank. The matrix \(\mathbf{B}_t\) can be constructed easily as follows. Put \((x_n,…,x_{n+k-1})’ = \mathbf{e}_j\), the \(j\)th vector of the canonical basis, with \(x_{n+i-1} = \delta_{ij}\), and compute the corresponding column vector \((y_n,…,y_{n+t-1})’\). This vector is the \(j\)th column of the matrix \(\mathbf{B}_t\).</p>
<h1>Lattice structure and spectral test</h1>
<p>Let \(\Psi_t\) be the multiset of all the \(t\)-dimensional vectors of successive output values of an MRG, from all possible seeds in \(\mathbb{Z}_m^k\), i.e., </p><p class="formulaDsp">
\[ \Psi_t = \left\{\mathbf{u}_{0,t} = (x_0/m,…,x_{t-1}/m) \mid(x_0,…,x_{k-1})\in\mathbb{Z}_m^k\right\}. \]
</p>
<p> For \(t\le k\), this set is just \(\mathbb{Z}_m^t\) with each element repeated \(m^{k-t}\) times. For \(t &gt; k\), the first \(k\) components of a vector \(\mathbf{u}_{0,t}\in\Psi_t\) are arbitrary elements of \(\mathbb{Z}_m/m\), but once they are fixed, the remaining \(t-k\) components are determined uniquely by the linear recurrence . The last \(t-k\) components are thus linear combinations modulo \(1\), with integer coefficients, of the first \(k\) components.</p>
<p>For \(1\le i\le k\), let \(\mathbf{v}_i = (v_{i,1},…,v_{i,t})\) be the \(t\)-dimensional vector with components \(v_{i,j}=\delta_{ij}/m\) for \(i\le k\), and \(v_{i,j} = (a_1 v_{i,j-1} +\cdots+ a_k v_{i,j-k})\mod1\) for \(j &gt; k\). For \(k+1\le i\le t\), let \(\mathbf{v}_i = \mathbf{e}_i\), the \(i\)th unit vector in \(t\) dimensions. These vectors are a basis of a lattice \(L_t\) that contains \(\mathbb{Z}^t\), with unit cell volume of \(\max(m^{-t}, m^{-k})\), such that \(L_t \cap[0,1)^t = \Psi_t\). In fact, \(L_t = \Psi_t + \mathbb{Z}^t = \{\mathbf{v}= \tilde{\mathbf{v}}+ \mathbf{z}\mid\tilde{\mathbf{v}}\in\Psi_t\) and \(\mathbf{z}\in\mathbb{Z}^t\}\). The vectors \(\mathbf{w}_i = (w_{i,1},…,w_{i,t})\), \(1\le i\le t\), where </p><p class="formulaDsp">
\[ w_{i,j} = \begin{cases} m &amp; \text{for $j=i\le k$}; \\ 0 &amp; \text{for $j\not i\le k$;} \\ v_{j,i} &amp; \text{for $i &gt; k\ge j$;} \\ 1 &amp; \text{for $j=i &gt; k$;} \\ 0 &amp; \text{for $k &lt; j\not i &gt;k$,} \end{cases} \]
</p>
<p> are linearly independent and satisfy \(\mathbf{v}_i\cdot\mathbf{w}_j = \delta_{ij}\). They form the dual basis to \(\{\mathbf{v}_1,…,\mathbf{v}_t\}\). The vectors \(\mathbf{v}_i\) and \(\mathbf{w}_j\) are the lines of the matrices: </p><p class="formulaDsp">
\[ \mathbf{V}_t = (\mathbf{v}_1 \mathbf{v}_2 \cdots\mathbf{v}_t)’ = \begin{pmatrix} 1/m &amp; 0 &amp; … &amp; 0 &amp; v_{1,k+1} &amp; … &amp; v_{1,t} \\ 0 &amp; 1/m &amp; … &amp; 0 &amp; v_{2,k+1} &amp; … &amp; v_{2,t} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; &amp; \vdots \\ 0 &amp; 0 &amp; … &amp; 1/m &amp; v_{k,k+1} &amp; … &amp; v_{k,t} \\ 0 &amp; 0 &amp; … &amp; 0 &amp; 1 &amp; … &amp; 0 \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; … &amp; 0 &amp; 0 &amp; … &amp; 1 \end{pmatrix} \]
</p>
<p> and </p><p class="formulaDsp">
\[ \mathbf{W}_t = (\mathbf{w}_1 \mathbf{w}_2 \cdots\mathbf{w}_t)’ = \begin{pmatrix} m &amp; 0 &amp; … &amp; 0 &amp; 0 &amp; … &amp; 0 \\ 0 &amp; m &amp; … &amp; 0 &amp; 0 &amp; … &amp; 0 \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; &amp; \vdots \\ 0 &amp; 0 &amp; … &amp; m &amp; 0 &amp; … &amp; 0 \\ -v_{1,k+1} &amp; -v_{2,k+1} &amp; … &amp; -v_{k,k+1} &amp; 1 &amp; … &amp; 0 \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ -v_{1,t} &amp; -v_{2,t} &amp; … &amp; -v_{k,t} &amp; 0 &amp; … &amp; 1 \end{pmatrix}, \]
</p>
<p> and one has \(\mathbf{W}’_t \mathbf{V}_t = I\). In the package <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a>, we store the vectors \(m\mathbf{v}_i\) instead of \(\mathbf{v}_i\) in the computer, for the components of the former vectors are integer-valued and can thus be represented exactly in the computer.</p>
<p>For the more general case of and replace the first \(k\) lines of \(\mathbf{V}_t\) by \(\mathbf{B}’_t\). If \(\mathbf{B}_k\) is invertible, then \(\mathbf{B}_t\) has rank \(k\) and the lines \(k+1\) to \(t\) of \(\mathbf{V}\) complete the lattice basis as before. Otherwise, remove the lines in \(\mathbf{B}’_t\) which are linearly dependent of others, to obtain a matrix of full rank \(k’&lt;k\), and replace them by \(k-k’\) vectors of the canonical basis of \(\mathbb R^t\), divided by \(m\), chosen in a way that the first \(k\) lines and \(k\) columns of \(\mathbf{V}_t\) form an invertible matrix. In both cases, the dual basis is obtained by inverting the matrix \(\mathbf{V}’_t\). For LCGs in matrix form, bases for \(L_t\) and its dual can be constructed as explained in <a class="el" href="citelist.html#CITEREF_rGRO88a">[16]</a>, <a class="el" href="citelist.html#CITEREF_rLEC94e">[26]</a>.</p>
<p>If one adds a constant \(b\) on the right-hand-side of , before applying the modulo operation, then the vectors of successive values will all belong to \(L’_t\), where \(L’_t = L_t + \mathbf{v}_{0,t}\) is a shift of \(L_t\) by some constant \(v_{0,t}\in\mathbb{Z}_m^t\), i.e., a <em>grid</em>. Since \(L’_t\) and \(L_t\) have the same structural properties, we simply ignore the presence of such a constant \(b\) in <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a>, and consider only homogeneous recurrences.</p>
<p>When \(m\) is prime and the MRG has full period \(m^k-1\), then \(\Psi_t\) is the set of all \(t\)-tuples produced by the generator over its main cycle, plus the <b>0</b> vector. Otherwise, the set of \(t\)-dimensional vectors produced over any given (sub)cycle (plus the <b>0</b> vector and plus \(m\mathbb{Z}^t\)) is a strict subset of \(L_t\) which in general does not form a lattice. Then, <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> can analyze the set of all \(t\)-tuples produced over the <em>union</em> of all subcycles. In some cases, however, the vectors of successive values over one subcycle generate a strict sublattice of \(L_t\), whose intersection with \([0,1)^t\) contains only a fraction of the points of \(\Psi_t\). This is what happens in particular when \(k=1\), \(m\) is a power of a prime \(p\), and \(x_0\) is prime to \(p\). The package can take care of the latter case by constructing a basis for the appropriate sublattice.</p>
<h1><a class="anchor" id="lacunary"></a>
Lacunary indices</h1>
<p>Instead of forming vectors with successive values like in the above definition of \(\Psi_t\), one can form vectors with values that are some distance apart in the sequence (so-called "leapfrog" values). a set of fixed integers. Define </p><p class="formulaDsp">
\[ \psi_t(I) = \left\{(u_{i_1},…,u_{i_t}) \mid(x_0,…,x_{k-1}) \in\mathbb{Z}_m^k\right\} \tag{psi2} \]
</p>
<p> and let \(L_t(I) = \psi_t(I) + \mathbb{Z}^t\). If we assume that \(0\le i_1 &lt; i_2 &lt; \cdots&lt; i_t\), this \(L_t(I)\) is the projection of the lattice \(L_{i_t+1}\) over the \(t\)-dimensional subspace determined by the coordinates that belong to \(I\). Using the class <code>IntLattice</code>, one can build a basis for \(L_t\) and its dual in this more general case, and then perform lattice analysis as usual. Further details and examples are given in <a class="el" href="citelist.html#CITEREF_rLEC97c">[25]</a>. For \((i_1,…,i_t) = (0,…,t-1)\), one has \(L_t(I) = L_t\).</p>
<p>To construct the basis in this case, one must compute the vector \((u_{i_1},…,u_{i_t})\) obtained when the seed \((x_0,…,x_{k-1})=\mathbf{e}_i\), for each vector \(\mathbf{e}_i\) of the canonical basis. The linear transformation from the state \((x_0,…,x_{k-1})\) to the vector \((u_{i_1},…,u_{i_t})\) is one-to-one for each \(t\ge k\) if and only if the transformation applied to the \(k\) vectors of the canonical basis gives \(k\) linearly independent vectors for \(t=k\). For \(t &lt; k\), the transformation is onto (surjective) if and only if the transformation gives \(t\) linearly independent vectors, that is, if the corresponding matrix has full rank \(t\).</p>
<h1><a class="anchor" id="merit"></a>
Figures of Merit</h1>
<p>Figures of merit measure the quality of lattices. Here, good quality means that the points cover the space very evenly, i.e., are very uniformly distributed. There are many ways of measuring this uniformity, which give rise to several different figures of merit.</p>
<h2><a class="anchor" id="spectral"></a>
The spectral test</h2>
<p>The lattice structure also means that all points of \(L_t\) lie in a family of equidistant parallel hyperplanes. Among all such families of hyperplanes that cover all the points, choose the one for which the successive hyperplanes are farthest apart. The distance between these successive hyperplanes is in fact equal to \(1/\ell_t\) where \(\ell_t\) is the Euclidean length of the shortest nonzero vector in the <em>dual</em> lattice \(L_t^*\). So for a given density of points, we want \(\ell_t\) to be as large as possible. Computing this \(\ell_t\) for an MRG and comparing with the best possible value, given \(t\), \(m\), and \(k\), is known as the <em>spectral test</em> in the literature on RNGs <a class="el" href="citelist.html#CITEREF_rKNU97a">[23]</a>, <a class="el" href="citelist.html#CITEREF_sFIS96a">[13]</a>.</p>
<p>We can view the lattice as a way of packing the space by spheres of radius \(\ell_t/2\), with one sphere centered at each lattice point. In the dual lattice, this gives \(1/n = m^{-k}\) spheres per unit volume. If we rescale so that the radius of each sphere is 1, we obtain \(\delta_t = (\ell_t/2)^t/n\) spheres per unit volume. This number \(\delta_t\) is called the <em>center density</em> of the lattice. For a given value of \(n\), an upper bound on \(\ell_t\) can be obtained in terms of an upper bound on \(\delta_t\) [one has \(\ell_t = 2 (n\delta_t)^{1/t}\)], and vice-versa. Let \(\delta_t^*\) be the largest possible value of \(\delta_t\) for a lattice (i.e., the densest packing by non-overlapping spheres arranged in a lattice). The quantity \(\gamma_t = 2(\delta_t^*)^{2/t}\) is called the <em>Hermite constant</em> for dimension \(t\) <a class="el" href="citelist.html#CITEREF_mCON99a">[5]</a>, <a class="el" href="citelist.html#CITEREF_mGRU87a">[17]</a>. It gives the upper bound \(\ell_t^2\le(\ell_t^*(n))^2 = 2(n\delta_t^*)^{2/t} = \gamma_t n^{2/t}\) for a lattice of density \(1/n\). Knowing the Hermite constants, or good approximations of them, is useful because it allows us to normalize \(\ell_t\) to a value between 0 and 1 by taking \(\ell_t/\ell_t^*(m^k)\). This is convenient for comparing values for different values of \(t\) and \(m^k\). Good values are close to 1 and bad values are close to 0.</p>
<p>The Hermite constants are known exactly only for \(t\le8\), in which case the densest lattice packings are attained by the <em>laminated</em> lattices <a class="el" href="citelist.html#CITEREF_mCON99a">[5]</a>. Conway and Sloane <a class="el" href="citelist.html#CITEREF_mCON99a">[5]</a> (Table 1.2) give the values of \(\delta_t^*\) for \(t\le8\), and provide lower and upper bounds on \(\delta_t^*\) for other values of \(t\). The largest value of \(\ell_t^2/n^{2/t}\) obtained so far for concrete lattice constructions is a lower bound on \(\gamma_t\), which we denote by \(\gamma_t^{\mathrm{B}}\). Such values are given in Table 1.2 of <a class="el" href="citelist.html#CITEREF_mCON99a">[5]</a>, page 15, in terms of \(\delta^*\). The laminated lattices, which give the lower bound \(\ell_t^2/n^{2/t} \ge\gamma_t^{\mathrm{L}} = 4 \lambda_t^{-1/t}\), where the constants \(\lambda_t\) are given in <a class="el" href="citelist.html#CITEREF_mCON88a">[4]</a> (Table 6.1, page 158) for \(t\le48\), are the best constructions in dimensions 1 to 29, except for dimensions 10 to 13. (One has \(\gamma_t^{\mathrm{L}} = \gamma_t\) for \(t\le8\).)</p>
<p>Minkowski proved that there exists lattices with density satisfying \(\delta_t \ge\zeta(t) / (2^{t-1} V_t)\) where \(\zeta(t) = \sum_{k=1}^{\infty}k^{-t}\) is the Riemann zeta function and \(V_t = \pi^{t/2} / (t/2)!\) is the volume of a \(t\)-dimensional sphere of radius 1. This bound provides a lower bound \(\gamma_t^Z\) on \(\gamma_t\).</p>
<p>An upper bound on \(\gamma_t\) is obtained via the bound of Rogers on the density of sphere packings <a class="el" href="citelist.html#CITEREF_mCON99a">[5]</a>. This upper bound can be written as </p><p class="formulaDsp">
\[ \gamma_t^{\mathrm{R}} = 4* 2^{2R(t)/t} \]
</p>
<p> where \(R(t)\) can be found in Table&#160;1.2 of <a class="el" href="citelist.html#CITEREF_mCON99a">[5]</a> for \(t\le24\), and can be approximated with \(O(1/t)\) error and approximately 4 decimal digits of precision, for \(t\ge25\), by </p><p class="formulaDsp">
\[ R(t) = \frac{t}{2} \log_2\left(\frac{t}{4\pi e}\right) + \frac{3}{2} \log_2 (t) - \log_2 \left(\frac{e}{\sqrt{\pi}}\right) + \frac{5.25}{t + 2.5}. \]
</p>
<p> Table&#160;1 in <a class="el" href="citelist.html#CITEREF_rLEC99c">[36]</a> gives the ratio \((\gamma_t^{\mathrm{L}} / \gamma_t^{\mathrm{R}})^{1/2}\), of the lower bound over the upper bound on \(\ell_t\), for \(1\le t\le48\). This ratio tends to decrease with \(t\), but not monotonously.</p>
<p>Computing the shortest vector in terms of the Euclidean norm is convenient, e.g., for computational reasons, but one can also use another norm instead. For example, one can take the \(\mathcal{L}_p\)-norm, defined by \(\Vert\mathbf{v}\Vert_p = (|v_1|^p + \cdots+ |v_t|^p)^{1/p}\) for \(1\le p &lt; \infty\) and \(\Vert\mathbf{v}\Vert_{\infty}= \max(|v_1|, …, |v_t|)\) for \(p = \infty\). The inverse of the length of the shortest vector is then the \(\mathcal{L}_p\)-distance between the successive hyperplanes for the family of hyperplanes that are farthest apart among those that cover \(L_t\). For \(p=1\), the length \(\ell_t = \Vert\mathbf{v}\Vert_1\) of the shortest vector \(\mathbf{v}\) (or \(\Vert\mathbf{h}\Vert_1 - 1\) in some cases, see <a class="el" href="citelist.html#CITEREF_rKNU97a">[23]</a>) is the minimal number of hyperplanes that cover all the points of \(\Psi_t\). The following upper bound on \(\ell_t\) in this case was established by Marsaglia <a class="el" href="citelist.html#CITEREF_rMAR68a">[40]</a> by applying the general convex body theorem of Minkowski: </p><p class="formulaDsp">
\[ \ell_t \le\ell_t^*(m^k) = (t! m^k)^{1/t} =: \gamma_t^M m^{k/t}. \]
</p>
<p> This upper bound can be used to normalize \(\ell_t\) in this case.</p>
<p>— Upper bound on \(\ell_t\) in general: Minkowski. ?</p>
<p>As a figure of merit, we take the worst-case value of \(\ell_t/\ell_t^*(m^k)\) over certain values of \(t\) and for selected projections on lower-dimensional subspaces. More specifically, let \(\ell_I\) denote the length of the shortest nonzero vector \(\mathbf{v}\) in \(L_t^*(I)\), and \(\ell_t = \ell_{\{1,…,t\}}\) as before. For arbitrary positive integers \(t_1\ge\cdots\ge t_d \ge d\), consider the worst-case figure of merit </p><p class="formulaDsp">
\[ M_{t_1,…,t_d} = \min\left[ \min_{k+1\le t\le t_1} \ell_t/\ell_t^*(m^k),\min_{2\le s\le k} \min_{I\in S(s,t_s)} \ell_I/m, \min_{k+1\le s\le d} \min_{I\in S(s,t_s)} \ell_I/\ell_s^*(m^k) \right], \tag{M} \]
</p>
<p> where \(S(s,t_s) = \{I=\{i_1,…,i_s\} \mid1 = i_1 &lt; \cdots&lt; i_s\le t_s\}\). This figure of merit makes sure that the lattice is good in projections over \(t\) successive dimensions for all \(t\le t_1\), and over non-successive dimensions that are not too far apart. Note that when \(s\le k\), the smallest distance between hyperplanes that can be achieved in \(s\) dimensions for the MRG is \(1/m\), so \(\ell_s/m\) cannot exceed 1, and it is equal to 1 if and only if the linear transformation from the state \((x_0,…,x_{k-1})\) to the output vector \((u_{i_1},…,u_{i_s})\) is surjective (i.e., the corresponding matrix has full rank). For \(s&lt;k\), \(m\) is typically much smaller than \(\ell_s^*(m^k)\), and this is the reason for separating the last two terms in .</p>
<p>The figure of merit \(M_{t_1} = \min_{2\le s\le t_1} \ell_s/\ell_s^*(n)\) (with \(d=1\)) has been widely used for ranking and selecting LCGs and MRGs <a class="el" href="citelist.html#CITEREF_sFIS96a">[13]</a>, <a class="el" href="citelist.html#CITEREF_rLEC99b">[35]</a>, <a class="el" href="citelist.html#CITEREF_rLEC99c">[36]</a>. The quantity \(M_{t_1,…,t_d}\) is a worst case over \((t_1-d) + \sum_{s=2}^d \binom{t_s-1}{s-1}\) projections, and this number increases quickly with \(d\) unless the \(t_s\) are very small. For example, if \(d=4\) and \(t_s = t\) for each \(s\), there are 5019 projections for \(t = 32\). When too many projections are considered, there are inevitably some that are bad, so the worst-case figure of merit is (practically) always small, and can no longer distinguish between good and mediocre behavior in the most important projections. Moreover, the time to compute \(M_{t_1,…,t_d}\) increases with the number of projections. We should therefore consider only the projections deemed important. We suggest using the criterion with \(d\) equal to 4 or 5, and \(t_s\) decreasing with \(s\).</p>
<p>Instead of considering the shortest nonzero vector in the dual lattice, one can consider the shortest nonzero vector in the primal lattice \(L_t\). Its length represents the distance to the nearest other lattice point from any point of the lattice. A small value means that many points are placed on the same line, at some fixed distance apart.</p>
<h2><a class="anchor" id="minkowski"></a>
Minkowski reduced basis</h2>
<p>Another way of measuring the quality of a lattice is in terms of the relative lengths of the smallest and largest vectors in a <em>reduced</em> basis. A basis can be <em>reduced</em> in different senses. One type of reduced basis considered by this package is a <em>Minkowski-reduced lattice basis</em> (MRLB) (see <a class="el" href="citelist.html#CITEREF_rAFF85a">[1]</a>, <a class="el" href="citelist.html#CITEREF_rAFF88a">[3]</a>, <a class="el" href="citelist.html#CITEREF_rGRO88a">[16]</a> for more details). Roughly, a MRLB is a basis for which the vectors are in some sense the most orthogonal. The ratio of the sizes of the shortest and longest vectors of a MRLB is called its <em>Beyer-quotient</em>. In general, a given lattice may have several MRLBs, all with the same length of the shortest vector, but perhaps with different lengths of the longest vector, and thus different Beyer quotients. We define \(q_t(I)\) as the maximum of the Beyer quotients of all MRLBs of \(L_t(I)\), and denote \(q_t(\{1,…,t\})\) by \(q_t\). We prefer values of \(q_t(I)\) close to 1. Similar to , we define </p><p class="formulaDsp">
\[ Q_{t_1,…,t_d} = \min\left[ \min_{k+1\le t\le t_1} q_t,\min_{2\le s\le d} \min_{I\in S(s,t_s)} q_t(I) \right]. \tag{Q} \]
</p>
<p> Computing \(q_t\) is much more time consuming than computing the spectral test.</p>
<h2><a class="anchor" id="palpha"></a>
The P alpha criterion</h2>
<p>The quantity \(\mathcal{P}_{\alpha}\) is a measure of non-uniformity (i.e., discrepancy from the uniform distribution, the smaller the better), which has been widely used in the context of quasi-Monte Carlo integration (see, e.g., <a class="el" href="citelist.html#CITEREF_vSLO94a">[51]</a>). In the case where \(\Psi_t = L_t \cap[0,1)^t\) where \(L_t\) is a lattice with dual \(L_t^*\), one has </p><p class="formulaDsp">
\[ \mathcal{P}_{\alpha}(\Psi_t) = \sum_{\boldsymbol{0}\not\mathbf{w}\in L_t^*} \|\mathbf{w}\|_{\pi}^{-\alpha}, \tag{palpha} \]
</p>
<p> where \(\|\mathbf{w}\|_{\pi}=\prod_{j=1}^t \max(1,|w_j|)\) for \(\mathbf{w}= (w_1,…,w_t)\). For any positive integer \(\alpha\), \(\mathcal{P}_{2\alpha}(\Psi)\) can be written equivalently as </p><p class="formulaDsp">
\begin{align} \mathcal{P}_{2\alpha}(\Psi_t) = -1 + \frac{1}{n}\sum_{\mathbf{u}\in\Psi_t} \prod_{j=1}^t \left[1 - \frac{(-4\pi^2)^{\alpha}}{(2\alpha) !} B_{2\alpha}(u_j)\right] \tag{palpha2} \end{align}
</p>
<p> where the \(B_{\alpha}\) are the Bernoulli polynomials: </p><p class="formulaDsp">
\begin{align*} B_0(x) &amp; = 1, \\ B_1(x) &amp; = x -1/2, \\ B_2(x) &amp; = x^2 - x + 1/6, \\ B_3(x) &amp; = x^3 - 3x^2/2 + x/2, \\ B_4(x) &amp; = x^4 - 2x^3 + x^2 - 1/30, \end{align*}
</p>
<p> and the other polynomials can be found via the identity </p><p class="formulaDsp">
\[ \frac{t e^{xt}}{e^t-1} = \sum_{i=0}^{\infty}\frac{ B_i(x) t^i}{i!}. \]
</p>
<p> Hickernell <a class="el" href="citelist.html#CITEREF_vHIC98c">[19]</a> introduced generalizations of \(\mathcal{P}_{\alpha}\), incorporating weights and replacing the simple sum in by a more general norm. One version of this weighted \(\mathcal{P}_{\alpha}\), where the weight associated to the projection over the coordinates in a set \(I\) has the <em>product-form</em> \(\beta_I = \beta_0\prod_{j\in I}\beta_j\), can be defined by </p><p class="formulaDsp">
\begin{align} \mathcal{P}_{2\alpha} (\Psi_t) = -\beta_0 + \frac{\beta_0}{n} \sum_{\mathbf{u}\in\Psi_t} \prod_{j=1}^t \left[1 - \frac{(-4\pi^2\beta_j^2)^{\alpha}}{(2\alpha)!} B_{2\alpha}(u_j)\right] \tag{palpha3} \end{align}
</p>
<p> when \(\alpha\) is an integer. The identity (palpha2)} or gives an algorithm for computing \(\mathcal{P}_{2\alpha}(\Psi_t)\) in time \(O(nt)\) when \(\alpha\) is an integer and \(\Psi_t\) is the intersection of a lattice with \([0,1)^t\). Note that the \(D_{\mathcal{F},\alpha,p}(P)\) of <a class="el" href="citelist.html#CITEREF_vHIC00b">[20]</a> corresponds to \((\mathcal{P}_{2\alpha}(\Psi_t))^{1/2}\) for \(\Psi_t=P\), \(p=2\), and \(\beta_j=1\) for all \(j\). <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> provides tools for computing \(\mathcal{P}_{\alpha}\) with or without weights.</p>
<p>It has been proved (e.g., <a class="el" href="citelist.html#CITEREF_vSLO94a">[51]</a>, Theorem 4.4, page 83) that for any \(t\ge2\), \(\alpha&gt; 1\), and prime number \(m &gt; e^{\alpha t/(\alpha-1)}\), there exists at least one LCG with modulus \(m\) such that </p><p class="formulaDsp">
\[ \mathcal{P}_{\alpha}(\Psi_t) \le\frac{[(e/t)(2\ln m + t)]^{\alpha t}}{ m^{\alpha}}. \]
</p>
<p> The latter quantity can then be used to normalize \(\mathcal{P}_{\alpha}\).</p>
<p>Alternatively, Hickernell et al. <a class="el" href="citelist.html#CITEREF_vHIC01a">[18]</a>, section 4.1, suggest using the figure of merit \(g_t\), where </p><p class="formulaDsp">
\begin{align} g_t^2 &amp; = \frac{n^2}{(3/2)^t-1} \left(\frac{t-1}{t-1+\log n}\right)^{t-1} \mathcal{P}_2(\Psi_t) \nonumber \\ &amp; = \frac{n}{ (3/2)^t-1} \left(\frac{t-1}{t-1+\log n}\right)^{t-1} \left[-n + \sum_{\mathbf{u}\in\Psi_t} \prod_{j=1}^t (1 + 3 B_{2\alpha}(u_j))\right] \tag{palpha4} \end{align}
</p>
<p> is a normalized version of the inverse of with \(\alpha=1\), \(\beta_0=1\), and \(\beta_j = \pi\sqrt{3/2}\) for \(j\ge1\). This \(g_t^2\) can be rewritten as </p><p class="formulaDsp">
\begin{align} g_t^2 &amp; = \gamma_t^{\mathrm{P}}(n) \left[-n + \sum_{\mathbf{u}\in\Psi_t} \prod_{j=1}^t (1 + 3 B_{2\alpha}(u_j))\right] \tag{palpha5} \end{align}
</p>
<p> where </p><p class="formulaDsp">
\[ \gamma_t^{\mathrm{P}}(n) = \frac{n}{ (3/2)^t-1} \left(\frac{t-1}{t-1+\log n}\right)^{t-1} \]
</p>
<p> is a constant that depends on \(t\) and \(n\). As a figure of merit based on \(\mathcal{P}_2\), similar to , we define </p><p class="formulaDsp">
\[ G_{t_1,…,t_d} = \min\left[ \min_{k+1\le t\le t_1} 1/g_t(\Psi_t), \min_{k+1\le s\le d} \min_{I\in S(s,t_s)} 1/g_t(\Psi_t(I)) \right]. \tag{G} \]
</p>
<h1><a class="anchor" id="gentype"></a>
Types of Multiple Recursive Generators</h1>
<h2><a class="anchor" id="MMRG_sec"></a>
Matrix multiple recursive generators</h2>
<p>MRGs in matrix form, which we denote MMRGs, have been introduced and studied by Niederreiter <a class="el" href="citelist.html#CITEREF_rNIE95b">[44]</a>, <a class="el" href="citelist.html#CITEREF_rNIE95c">[45]</a>. The general recurrence has the form </p><p class="formulaDsp">
\[ \mathbf{x}_n = (A_1 \mathbf{x}_{n-1} + \cdots+ A_k \mathbf{x}_{n-k}) \mod m \tag{MMRG} \]
</p>
<p> where \(k\) and \(m\) are the order and the modulus as for the MRG, \(\mathbf{x}_n = (x_{n,1},…,x_{n,w})’\) is a \(w\)-dimensional vector, and each \(A_j\) is a \(w\times w\) square matrix, for some positive integer \(w\). The case \(w=1\) corresponds to the usual MRG. The recurrence has full period \(m^{kw}-1\) if and only if \(m\) is prime and the characteristic polynomial </p><p class="formulaDsp">
\[ f(x) = \det\left( x^k I - x^{k-1} A_1 - x^{k-2} A_2 - \cdots- A_k\right) \]
</p>
<p> is a primitive polynomial modulo \(m\) <a class="el" href="citelist.html#CITEREF_rNIE95b">[44]</a>.</p>
<p>There are different ways of producing the output. We consider the following 3 cases: </p><p class="formulaDsp">
\begin{align} u_{nw+i} &amp; = x_{n,i} / m \qquad\mbox{ for $0\le i&lt;w$ and $n\ge0$}, \tag{out1} \\ u_n &amp; = \frac{1}{ m} \left(\sum_{i=1}^w b_i x_{n,i} \mod m\right) = \sum_{i=1}^w b_i x_{n,i} / m \mod1 \qquad\mbox{ for $n\ge0$}, \tag{out2} \\ u_n &amp; = \sum_{i=1}^w x_{n,i} m^{-i} \qquad\mbox{ for $n\ge0$}, \tag{out3} \end{align}
</p>
<p> where \(b_1,…,b_w\) are positive integers. Case 3 is that used in <a class="el" href="citelist.html#CITEREF_rNIE95b">[44]</a> and does not give rise to a lattice structure for \(\Psi_t\) in the usual sense. For both cases 1 and 2, the set \(\Psi_t\) is the intersection of a lattice \(L_t\) with the unit hypercube. Case 1 is used in <a class="el" href="citelist.html#CITEREF_rNIE95c">[45]</a>, where pseudorandom numbers are generated in vector form, \(w\) at a time. It is also explained in <a class="el" href="citelist.html#CITEREF_rNIE95c">[45]</a> how to construct a basis for the lattice \(L_t\) when \(t\) is a multiple of \(w\). (The generalization to other values of \(t\) is trivial.)</p>
<p>— Give equivalence with MRG.</p>
<h2><a class="anchor" id="MWC_sec"></a>
Multiply-with-carry</h2>
<p>A <em>Multiply-with-Carry</em> (MWC) generator <a class="el" href="citelist.html#CITEREF_rCOU95a">[6]</a>, <a class="el" href="citelist.html#CITEREF_rCOU97a">[9]</a>, <a class="el" href="citelist.html#CITEREF_rKOC95a">[24]</a>, <a class="el" href="citelist.html#CITEREF_rMAR94a">[41]</a> is based on the recurrence </p><p class="formulaDsp">
\begin{align} x_n &amp; = (a_1 x_{n-1} + \cdots+ a_k x_{n-k} + c_{n-1}) \mod b, \tag{mwc1} \\ c_n &amp; = (a_1 x_{n-1} + \cdots+ a_k x_{n-k} + c_{n-1}) \div b, \tag{mwc2} \\ u_n &amp; = x_n / b. \nonumber \end{align}
</p>
<p> where "div" denotes the integer division. The recurrence looks like that of an MRG, except that a <em>carry</em> \(c_n\) is propagated between the steps.</p>
<p>Assume that \(b\) is a power of 2, define \(a_0 = -1\), </p><p class="formulaDsp">
\[ m = \sum_{\ell=0}^k a_{\ell}b^{\ell}, \]
</p>
<p> and let \(a\) be the inverse of \(b\) in arithmetic modulo \(m\). For simplicity, assume \(m &gt; 0\). Then, up to precision \(1/b\), the MWC generator is equivalent to the LCG: </p><p class="formulaDsp">
\[ z_n = a z_{n-1} \mod m; \qquad w_n = z_n/m. \tag{lcgz} \]
</p>
<p> In other words, if </p><p class="formulaDsp">
\[ w_n = \sum_{i=1}^{\infty}x_{n+i-1} b^{-i} \tag{wdigit} \]
</p>
<p> holds for \(n=0\), then it holds for all \(n\), and consequently \(|u_n - w_n| \le1/b\) for all \(n\). The (approximate) lattice structure of the MWC can therefore be analyzed by analyzing that of the corresponding LCG . This is what the <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> package does.</p>
<p>If \(a_{\ell}\ge0\) for \(\ell\ge1\), then all the recurrent states of the MWC satisfy \(0\le c_n &lt; a_1 + \cdots+ a_k\). In view of this inequality, we want the \(a_{\ell}\) to be small, so that their sum fits into a computer word (e.g., \(a_1 + \cdots+ a_k \le b\)). But the coefficients should not be too small either, because in dimension \(t = k+1\), one has (see <a class="el" href="citelist.html#CITEREF_rCOU97a">[9]</a>): </p><p class="formulaDsp">
\[ \ell_t = (1 + a_1^2 + \cdots+ a_k^2)^{1/2}. \tag{dtkp1} \]
</p>
<p> Since \(b\) is a power of 2, \(a\) is a quadratic residue and so cannot be primitive mod \(m\). Therefore the period length cannot reach \(m-1\) even if \(m\) is prime. But if \((m-1)/2\) is odd and 2 is primitive mod \(m\) (e.g., if \((m-1)/2\) is prime), then has period length \(\rho= (m-1)/2\).</p>
<h2><a class="anchor" id="combo_sec"></a>
Combined generators</h2>
<p>Combining LCGs or MRGs with relatively prime moduli provides a efficient way of implementing linear recurrences based on larger (non-prime) moduli. The combination method that we consider adds, modulo \(1\), the outputs of the components. The package <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> permits one to specify a <em>product</em> MRG in terms of its component MRGs with relatively prime moduli (see class <code>MRGLatticeFactory)</code>. Its modulus is the product of the component moduli and its order is the maximum of the orders of the components. The recurrence governing this product MRG, when taken modulo any one of the component moduli, reduces to the component recurrence. The combined generator can then be studied via this product generator, since one can view the former as embedded in the latter, and since both have the same set of recurrent states (see <a class="el" href="citelist.html#CITEREF_rCOU96a">[8]</a>). Facilities are provided to analyze, for any given MRG, either the lattice \(L_t\) generated by all possible initial states, or that generated by the set of recurrent states (see <code>LatticeType</code> in module <code>Const</code> and in programs <code>seek*</code>).</p>
<p>Other types of combinations that have been proposed in the literature are (often, depending on the parameters) closely approximated by combinations of the above types <a class="el" href="citelist.html#CITEREF_rLEC91b">[27]</a>, <a class="el" href="citelist.html#CITEREF_rLEC96b">[32]</a>. They can thus be analyzed with the present software.</p>
<h1><a class="anchor" id="computing_short"></a>
Computing a shortest nonzero vector or a reduced basis</h1>
<p>The class <code>Reducer</code> computes a shortest nonzero vector in a lattice via the branch-and-bound (BB) algorithm proposed by <a class="el" href="citelist.html#CITEREF_mFIN85a">[11]</a>, with some additional refinements. For large dimensions \(t\), this algorithm is much faster than the algorithm given in <a class="el" href="citelist.html#CITEREF_rDIE75a">[10]</a>, <a class="el" href="citelist.html#CITEREF_rKNU81a">[21]</a>. The class also computes a Minkowski reduced basis via the algorithm of <a class="el" href="citelist.html#CITEREF_rAFF85a">[1]</a>, which works by successive applications of the BB procedure for finding a shortest vector. The bounds in the BB procedure are computed through a Choleski decomposition performed in (double precision) floating-point arithmetic. Numerical roundoff errors occur during these computations and could (eventually) affect the results: Because of slightly wrong bounds in the BB, one may miss a shorter vector and, as a result, (conceivably) not obtain a true MRLB at the end of the reduction algorithm. In that case, one may consider redoing the computations with the NTL type <code>RR</code>, used to represent arbitrary-precision floating-point numbers (see LatticeTester module Types) but giving rise to much slower programs.</p>
<h1><a class="anchor" id="numbers_sec"></a>
Large numbers, matrices and polynomials</h1>
<p><a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> can deal with very large moduli and multipliers. There is no limit on size other than the size of the computer memory (and the CPU time). For example, a generator with a modulus of a few hundred bits can be analyzed easily. Operations on large integers are performed using the GNU multi-precision package GMP <a class="el" href="citelist.html#CITEREF_iGMP06a">[14]</a>. GMP is a portable library written in C for arbitrary precision arithmetic on integers, rational numbers, and floating-point numbers. For vectors, matrices of large numbers and polynomials, we use NTL <a class="el" href="citelist.html#CITEREF_iSHO05a">[50]</a>. NTL is a high-performance, portable C++ library providing data structures and algorithms for manipulating arbitrary length integers, and for vectors, matrices, and polynomials over the integers and over finite fields. NTL uses GMP as an underlying package for dealing with large numbers.</p>
<p>Of course, arithmetic operations with these structures are performed in software and are significantly slower than the standard operations supported by hardware. For this reason, most of the basic (low-level) operations required by our higher-level classes have been implemented in two or three versions. When building a basis or checking maximal period conditions, the modulus and multipliers can be represented either as <code>long</code>’s (32-bit integers) or <code>ZZ</code>’s (arbitrary large integers). After a lattice basis and its dual have been constructed, when working on the basis (finding a shortest vector, Minkowski reduction, etc.), the vector elements can be represented either as <code>double</code>’s (64-bit floating-point numbers) or <code>RR</code>’s (arbitrary large floating-point numbers).</p>
<p>When performing a search for good generators, for instance, one can first perform all the "screening" computations (involving many generators) using standard type <code>double</code>, and then recompute (verify) with the large floating-point numbers <code>RR</code> only for the retained generators. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LatMRG Guide: Compilation and Executables Usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LatMRG Guide
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A software package to test and search for new linear congruential random number generators</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('usage.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Compilation and Executables Usage </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="usage_exec"></a>
LatMRG executable</h1>
<p>As of the latest update, <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> possesses a single executable taking all it's options from configuration files. This executable has 4 different execution modes that simply the usage of the core functionnalities of <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a>.</p><ul>
<li>A mode to search of \(m\) and \(k\) parameters for MRG generators.</li>
<li>A mode to test if a specific MRG has full period.</li>
<li>A mode to test MRG generators with figures of merit tests built upon the computations <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> can perform on lattice.</li>
<li>A mode to search for new MRG generators, using the same kind of tests as the test mode.</li>
</ul>
<p>We briefly introduce what each mode can do, before presenting the program usage.</p>
<h2><a class="anchor" id="usage_exec_mk"></a>
Searching m and k parameters</h2>
<p>This mode will search for good modulus in a certain range given a number \(k\). This is used when searching for new generators with full period.</p>
<p>This will search for prime \(m\) in \(m &lt; 2^e\) or \( 2^e+c_1 \le m \le 2^e+c_2\). When doing these search, it is possible to ask that \(r = (m^k-1)/(m-1)\) is prime and that \((m-1)/2\). It is also possible to ask the program to factor \(m-1\) to a file.</p>
<p>All these factorisations and restrictions on primality are useful because they simplify the initialization process of the search program, as the factorization of \(r\) and \((m-1)/2\) is needed to check the full period of a generator.</p>
<h2><a class="anchor" id="usage_exec_period"></a>
Checking for full period</h2>
<p>This mode takes a generator and tests if it's period length is maximal. This will need a factorization for \(r\) and \(m-1\) which can be very long to compute. Accomplishing this factorization outside of the main program is the main use case of this mode. Using this seperately of the generator testing gives you more flexibility with the execution time.</p>
<h2><a class="anchor" id="usage_exec_lattest"></a>
Testing lattice structure for MRG</h2>
<p>This mode takes a generator, a test, a description of how to apply this test and performs the test on the generator. The generator can be of any of the types of MRG described in <a class="el" href="background.html">Theory of Random Numbers</a>.</p>
<p>The program can perform multiple computations:</p><ul>
<li>The length of the shortest vector in the lattice of the generator in L1 and euclidian norm.</li>
<li>The length of the shortest vector in the dual lattice of the generator</li>
<li>The preceding norms normalized between 0 and 1</li>
</ul>
<p>But it's real strength lies in the fact that it can build the generator lattice and dual lattice for any projection of the generator, and compute figures of merit based on the normalized mesures on these multiple projections. Computing these figures of merit is really the main reason to use this mode.</p>
<p>To execute the program, it is necessary to feed it with the set of of the generator that you want to test. This program takes a values for \(T\), \(d\) and \(T_2, \ldots, T_d\) such that the program will test all projections of the form \(\{0, \ldots, t\}\) with \(k \le t &lt; T\), and projections on indices \(\{i_1, \ldots, i_j: 0 \leq i_k \le T_j\}\) for \(2 \le j \le d\).</p>
<h2><a class="anchor" id="usage_exec_search"></a>
Searching for new MRG</h2>
<p>This mode takes configuration of MRG generators (such and the modulo, the order and ranges for the parameters) and randomly searches for parameters that fit this configuration. Once a generator is found, it is tested with the same methodology as in the preceding <a class="el" href="usage.html#usage_exec_lattest">Testing lattice structure for MRG</a> mode and generators are ranked by the value they get in these tests.</p>
<p>Even though a lot for flexibility is available when using this mode, it is usual to compare generators with figures of merit between 0 and</p>
<h2><a class="anchor" id="usage_exec_usage"></a>
Usage of the executable</h2>
<p>We do not provide a precompiled binairy for the main executable. To use it you must first compile it following the instructions following this section. Once this is done, you will find the main <code>MRGLattice</code> executable in the <code>bin</code> directory of the software repository.</p>
<p>As any executable, the executable can be called from the command line as </p><div class="fragment"><div class="line">./MRGLattice &lt;LD, ZD, ZR&gt; file1 file2 ...</div></div><!-- fragment --><p> It is necessary to specify configuration files for the program to actually do stuff. The option of <code>LD</code>, <code>ZD</code> or <code>ZR</code> can be used to change the numeric types used by the program. It can be ommited, its default value is <code>ZD</code>. For more information on what this option means, you can have a look at <a class="el" href="tutorial.html#classes_list_types">Types in LatMRG</a>.</p>
<p><b>NEW</b> As of the last upgrade to <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a>, the executable now reads it's configuration from <code>xml</code> files. Since configuration files have a quite extensive set of tags allowing users to specify the options, the list of these tags and their usage for the different modes is specified in <a class="el" href="conf_file.html">Configuration Files Synthax and Tags</a>.</p>
<h1><a class="anchor" id="compilation"></a>
Building LatMRG</h1>
<p><a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> is available on <a href="https://github.com/savamarc/latmrg"><b>Github</b></a> and can be downloaded either via <code>git</code> or as a <code>.zip</code> archive. We do not provide precompiled binairies, so you have to follow these instruction to use the software. Once you have the repository on a local machine, it is necessary to make sure that you have the correct dependencies installed:</p><ul>
<li><a href="https://www.shoup.net/ntl/"><b>NTL</b></a> version 10.5.0 or later is needed. Follow Shoup's instructions to install the library compiled with the option <code>NTL_THREADS=off</code> in a standard path.<ul>
<li><a href="https://gmplib.org/"><b>gmp</b></a> is a NTL dependency. It is packaged by most major Linux distributions. You will need to also download the header files of the library (usually in a <code>-dev</code> or <code>-devel</code> named package).</li>
</ul>
</li>
<li><a href="https://github.com/umontreal-simul/latticetester"><b>Lattice Tester</b></a> is a submodule in the git repository. The instructions bellow present how to download and compile Lattice Tester along <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a>.</li>
<li><a href="https://github.com/leethomason/tinyxml2"><b>tinyxml2</b></a> A small library to parse xml documents. This should be available through the package manager of most linux distributions. The header file of the library is shipped as part of the <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> code.</li>
<li><a href="https://git-scm.com"><b>git</b></a> will greatly simplify the download process for both <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> and Lattice Tester.</li>
<li><a href="https://sourceforge.net/projects/yafu/"><b>yafu</b></a> is an external executable that is used for factorization when checking that generators have full period. It is not necessary to have it when building, but the program will halt when asked for a factorization. If you want to avoid this behavior, download and unpack this executable in the <code>data</code> directory.</li>
</ul>
<p>To build the program, it will also be necessary to have a recent C++ compiler and Python interpreter installed. Note that we do not provide instructions to build the library under Windows or macOS, and that the software is only tested for the <code>x86_64</code> architecture. Also note that we currently do not use automatic <code>makefile</code> generation and that you will need to manually modify the makefile for any non standard path choices.</p>
<p>First, download the source code via github as a <code>.zip</code> unpack it and open a terminal in that directory, or use git: </p><div class="fragment"><div class="line">git clone --recursive https:<span class="comment">//github.com/savamarc/LatMRG.git</span></div><div class="line">cd <a class="code" href="namespace_lat_m_r_g.html">LatMRG</a></div></div><!-- fragment --><p> If you downloaded the zip, you will also need to download and extract Lattice Tester. In the <code>latticetester</code> directory. Once this is done, the program can be compiled in only a few commands. Note that the first one is interractive. </p><div class="fragment"><div class="line">make config_latticetester</div><div class="line">make</div></div><!-- fragment --><p> Once this is done, the executables can be invoked from the local directory as <code>./bin/Program_name data_file</code>.</p>
<p>Note that there is no way to install the program somewhere else. If <code>yafu</code> is used by the program, it might be problematic to move the binaries. This is because the program uses a relative path to invoke <code>yafu</code>. We are aware of these issues and they will be fixed some time in the future.</p>
<h1><a class="anchor" id="program"></a>
A programmer's guide to LatMRG</h1>
<p>In this section, we will present how to use <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> as a library and provide guidelines on how to expand the software.</p>
<h2><a class="anchor" id="program_types"></a>
Working with types</h2>
<p>The first thing anyone programming with <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> should know, is that <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> HAS TO perform on different types depending on the use case. Therefore, when programming new functions in <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> it is necessary to make sure that they are agnostic the possible types that might be used by the different <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> objects. Currently <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> can use <code>ZZ</code> from the NTL library, as well as fixed width <code>int64_t</code> integers to represent the generators and their basis. It can also represent floating point numbers with both <code>double</code> and <code>RR</code> types. Note that there is one cavehat to the previous statements: the BKZ reduction method (in LatticeTester) requires that integers are of the <code>ZZ</code> type. This is because we did not implement the BKZ reduction and use the NTL version instead. This version does not operate on <code>long</code> integers.</p>
<p>To work around this problem, <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> uses templates for most classes. This can feel problematic since these templates are not intended to work with most types ut only a few specific ones. This is mainly meant to reduce code duplication, but also gives us the flexibility to eventually change NTL for another library and not have to rewrite most of our code base. This is also intended to modify the old version of <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> that used compile time flags to determine the types.</p>
<p>Template classes in the software look like this: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Integ, <span class="keyword">typename</span> Float&gt; <span class="keyword">class </span>LatMRGClass {</div><div class="line">  <span class="keyword">typedef</span> Integ Int;</div><div class="line">  <span class="keyword">typedef</span> Float Dbl;</div><div class="line">  ...</div><div class="line">};</div><div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>LatMRGClass&lt;std::int64_t, double&gt;;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>LatMRGClass&lt;NTL::ZZ, double&gt;;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>LatMRGClass&lt;NTL::ZZ, NTL::RR&gt;;</div></div><!-- fragment --><p> The first thing to note are the <code>typedef</code>s. Having them means that it is possible to interract with the class and its types and still write types agnostic code by referring to <code>typename LatMRGClass::Int</code>. The other thing to note is that the library instanciates all its templated classes with the types we support. This is meant to reduce compile time when using the library and helps verify that supported types works.</p>
<h2><a class="anchor" id="program_creating"></a>
Adding new types of generators</h2>
<p>Although it shouldn't be necessary to add new types of generators in the the software, it is possible that some users would want to include classes to represent specific parameter combinations for certain generator kinds and specialize the lattice construction for those. For all its operation on generators, <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> interracts with the base class <code>MRGLattice</code>. This class inherits from <code>IntLattice</code> in LatticeTester and has quite a few functions that can be specialized in subclasses.</p>
<p>To specialize the basis construction, all subclasses for MRGLattice can reimplement the virtual methods <code>buildBasis(int)</code> and <code>incDim()</code>. The first method is intended to build a basis of dimension specified as argument, and the second one increases the basis dimension by one.</p>
<p>The other main function you might want to specialize in <code>MRGLattice</code> is the <code><a class="el" href="namespace_lat_m_r_g.html#a917092d920554daac078d0f53c28eabc" title="Returns the value of the duration from timer.">toString()</a></code> function. This function returns a string that describes the generator represented by the lattice. There curently is no standard format to be returned by this method and it is left to the user discretion to choose what information is important. For example, for <code>MRGLattice</code>, this only prints the coefficients as </p><div class="fragment"><div class="line">a1 = x1</div><div class="line">...</div><div class="line">ak = xk</div></div><!-- fragment --><p> but it could be possible to create a class that represents a MRG with specific choice of coefficients. For example, if the coefficients are chosen as the sum of powers of primes <code>p1</code>, ..., <code>pj</code> one could change the method to print <code>a1 = x1 = p1^e1 + ... + pj^ej</code>.</p>
<h2><a class="anchor" id="program_expanding"></a>
Expanding the executable</h2>
<p>One of the reasons you might want to use <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> is to search for generators. The main tool <a class="el" href="namespace_lat_m_r_g.html">LatMRG</a> provides for this is its executable, but this means expanding the search functionnality of the software is not as easy as writing a function to generate vectors \((a_1, \ldots, a_k)\) given a strategy. Even though it is necessary to meddle with the executable, the Seek mode provides an easy way to add search methods.</p>
<p>To search for generators, the program calls the following function: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Lat&gt; <span class="keyword">struct </span>SeekMain {</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Lat::Int Int;</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Lat::Dbl Dbl;</div><div class="line">  <span class="keyword">typedef</span> NTL::vector&lt;Int&gt; IntVec;</div><div class="line">  <span class="keyword">typedef</span> NTL::matrix&lt;Int&gt; IntMat;</div><div class="line"></div><div class="line">  ConfigSeek&lt;Int, Dbl&gt; conf;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">  <span class="keywordtype">int</span> Seek (Lat* (*nextGenerator)(ConfigSeek&lt;Int, Dbl&gt;&amp;) )</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (!conf.gen_set) {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;No generator set for in seek tag. Aborting.\n&quot;</span>;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!(conf.test_set)) {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;No test set for in seek tag. Aborting.\n&quot;</span>;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (!conf.proj_set) {</div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;No projections set for in seek tag. Aborting.\n&quot;</span>;</div><div class="line">      <span class="keywordflow">return</span> 1;</div><div class="line">    }</div><div class="line">    <span class="comment">// Initializing values</span></div><div class="line">    <span class="comment">// Dynamically allocated objects</span></div><div class="line">    timer.init();</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> old = 0;</div><div class="line">    <span class="comment">// Launching the tests</span></div><div class="line">    <span class="keywordflow">if</span> (conf.progress) {</div><div class="line">      old = print_progress(-1);</div><div class="line">    }</div><div class="line">    MeritList&lt;Lat&gt; bestLattice(conf.max_gen, conf.best);</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line">      <span class="keywordflow">if</span> (lat != NULL) <span class="keyword">delete</span> lat;</div><div class="line">      lat = nextGenerator(conf);</div><div class="line">      <span class="keywordflow">if</span> (lat == NULL) <span class="keywordflow">continue</span>;</div><div class="line">      bestLattice.add(test_seek(*lat, conf));</div><div class="line">      conf.num_gen++;</div><div class="line">      conf.currentMerit = bestLattice.getMerit();</div><div class="line">      <span class="keywordflow">if</span> (conf.progress) old = print_progress(old);</div><div class="line">    } <span class="keywordflow">while</span> (!timer.timeOver(conf.timeLimit) &amp;&amp; lat);</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\r                                                                                                          \r&quot;</span>;</div><div class="line">    printResults(bestLattice);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  }</div><div class="line">}; <span class="comment">// end struct SeekMain</span></div></div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>

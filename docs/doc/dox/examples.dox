/**
 * \page tutorial Tutorial and Library Usage
 *
 * Most use cases should already be covered by the executable programs, but
 * LatMRG is also distributed as a library to easily expand its functions.
 * You might want to:
 * - Perform tests in a sequence or on subsets that we do not provide
 * - Test unimplemented forms of generators
 * - Implement new tests and figures of merit
 *
 * With some knowledge of the C++ programming language, it is possible to use
 * the classes and functions of LatMRG as tools to write your own programs.
 * This section first presents the main classes of the library and covers a few
 * examples of its usage.
 *
 * \section classes_list Classes of LatMRG
 *
 * The most important feature of LatMRG is its capacity to represent MRG random
 * number generators and their lattices. The library features two different
 * classes in this regard, depending on the use case.
 *
 * `LatMRG::MRGLattice` is the main class to do so. This class allows the
 * the storage of a MRG's parameters and also the reprensentation of a basis for
 * this generator. This class also has an overridable interface to build the
 * basis of the generator lattice for an arbitrary dimension.
 *
 * A common way to
 * to use this class is to simply create a subclass that initializes the
 * `MRGLattice` components in its constructor. Recall that most MRG type
 * generators are equivalent to a MRG in some way and that it is generaly easy
 * to just take a list of parameters and convert them. This is what is done in
 * `LatMRG::ComboLattice`, `LatMRG::MWCLattice` and `LatMRG::AWCSWBLattice`.
 * For example, the next few lines of code (and a few more declaration in the
 * class body) are what initializes a
 * `MWCLattice` with
 * \f{align}{
 *    x_n & = (e_1 x_{n-1} + \cdots + e_k x_{n-k} + c_{n-1})d\ \mathrm{mod} \ b, \\
 *    c_n & = \lfloor (e_0 x_n + e_1 x_{n-1} + \cdots + e_k x_{n-k} + c_{n-1} )/b \rfloor, \\
 *    u_n & = \sum_{i=1}^\infty x_{n+i-1} b^{-i}.
 * \f}
 * The resulting object can then be used in any function working on
 * `MRGLattice`s seamlessly.
 *
 * \code{.cpp}
 * template<typename Int>
 *   Int LCGMod(const Int& b, const NTL::vector<Int>& e){
 *     Int m(0);
 *     for(int i = 0; i <= e.length(); i++) {
 *       m += e[i] * NTL::power(b, i);
 *     }
 *     return m;
 *   }
 * 
 * template<typename Int>
 *   NTL::vector<Int> LCGCoeff(const Int& b, const NTL::vector<Int>& e){
 *     Int mult = LCGMod(b,e);
 *     std::cout << b << "\n";
 *     Int a = NTL::InvMod(b, mult);
 *     NTL::vector<Int> coeff;
 *     coeff.SetLength(2);
 *     coeff[1] = a;
 *     return coeff;
 *   }
 *
 * template<typename Int, typename Dbl>
 *   MWCLattice<Int, Dbl>::MWCLattice(const Int & b, const IntVec & e, int k):
 *     MRGLattice<Int, Dbl>(LCGMod(b, e), LCGCoeff(b,e), 1, 1, FULL)
 * {
 *   m_MWCmod = b;
 *   m_MWCorder = k;
 *   m_eCoef.SetLength(k+1);
 *   for (int i = 0; i < k+1; i++)
 *     m_eCoef[i] = e[i];
 * }
 * \endcode
 *
 * \todo Replace section numbers with appropriate links.
 *
 *   # Using the classes of LatMRG
 *
 *   The modules of LatMRG (excluding the executable programs) have
 * been classified in two sets: lower-level and intermediate-level. The
 * lower-level modules offer basic facilities for arithmetic operations and
 * conversions, with different representations, for basis vectors and
 * multipliers. They are described in the NTL documentation (see the URL
 * [http://shoup.net/ntl/doc/tour.html](http://shoup.net/ntl/doc/tour.html)).
 *
 *   The intermediate-level classes inheriting from the virtual class
 * <tt>IntLattice</tt> constructs lattice bases for different kinds of
 * generators or point sets. The currently implementing classes are
 * <tt>Rank1Lattice</tt>, <tt>KorobovLattice</tt> and <tt>MRGLattice</tt>.
 * <tt>IntLattice</tt> itself offers tools for manipulating lattice bases,
 * and generally does common operations on bases. The class <tt>Reducer</tt>
 * performs tests on these lattices, such as finding the shortest vector in a
 * lattice, and reducing a basis in the sense of Minkowski. Those classes are
 * described in the following chapters. The programs described in
 * \ref usage use those intermediate and
 * lower-level classes in their implementation, and so, provide examples of
 * how to use them.
 *
 *   # Lower-level modules and Changing the representation
 *
 *   As discussed in section \ref numbers_sec, the
 * multiplierâ€™s components can be implemented in the <tt>long</tt> or
 * <tt>ZZ</tt> representation, while the basis components can be in the
 * <tt>double</tt> or <tt>RR</tt> representation. To select the appropriate
 * representation (see modules <tt>Types</tt> where all the basic possible
 * types are selected), one should compile and link his programs with one of
 * the libraries <tt>liblatLLDD.a</tt>, <tt>liblatZZDD.a</tt> or
 * <tt>liblatZZRR.a</tt>. Generally speaking, the proper choice of
 * representation depends on the size of the modulus \f$m\f$. For example, if
 * \f$m\f$ is less than \f$2^{25}\f$, then the library <tt>liblatLLDD.a</tt>
 * should be appropriate. For most cases, the library <tt>liblatZZDD.a</tt>
 * will be satisfactory.
 *
 */

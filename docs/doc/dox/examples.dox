/**
 * \page tutorial Tutorial and Library Usage
 *
 * Most use cases should already be covered by the executable programs, but
 * LatMRG is also distributed as a library to easily expand its functions.
 * You might want to:
 * - Perform tests in a sequence or on subsets that we do not provide
 * - Test unimplemented forms of generators
 * - Implement new tests and figures of merit
 *
 * With some knowledge of the C++ programming language, it is possible to use
 * the classes and functions of LatMRG as tools to write your own programs.
 * This section first presents the main classes of the library and covers a few
 * examples of its usage.
 *
 * \section classes_list Classes of LatMRG
 *
 * \subsection classes_list_types Types in LatMRG
 *
 * If you browse the LatMRG source code, you will notice that a lot of classes
 * are template classes. This is because the arithmetic can be done with a
 * variable level of precision depending on the usage. Template classes feature
 * readily available template instantiation with relevant types and types
 * combinations in the library.
 *
 * For integers, types we use are fixed width 64 bits integers `std::int64_t`
 * and the arbitrary precision integers of NTL `NTL::ZZ`. For floating point
 * numbers, the template parameters types can be `double` or `NTL::RR`.
 * Standard types `std::int64_t` and `double` perform much faster, but they
 * have a limited precision. This is specially important for integers: lattices
 * basis need to be stored exactly for the program to work properly. If you
 * think you might need to store a number greater than `2^63-1`, it is best to
 * use arbitrary precision integers.
 * \remark If you manipulate integers that are bigger than `2^32`, the result of
 * a multiplication can overflow. Multiplications will occur when building a
 * lattice basis.
 *
 * \subsection classes_list_mrg MRG Representation
 *
 * The most important feature of LatMRG is its capacity to represent MRG random
 * number generators and their lattices. The library features two different
 * classes in this regard, depending on the use case.
 *
 * `LatMRG::MRGLattice` is the main class to do so. This class allows the
 * the storage of a MRG's parameters (a vector of multipliers, a modulo and an
 * order) and also the reprensentation of a lattice basis for
 * this generator. This class also has an overridable interface to build the
 * basis of the generator lattice for an arbitrary dimension.
 *
 * A common way to
 * to use this class is to simply create a subclass that initializes the
 * `MRGLattice` components in its constructor. Recall that most MRG type
 * generators are equivalent to a MRG in some way and that it is generaly easy
 * to just take a list of parameters and convert them. This is what is done in
 * `LatMRG::ComboLattice`, `LatMRG::MWCLattice` and `LatMRG::AWCSWBLattice`.
 * For example, the next few lines of code (and a few more declaration in the
 * class body) are what initializes a
 * `MWCLattice` with
 * \f{align}{
 *    x_n & = (e_1 x_{n-1} + \cdots + e_k x_{n-k} + c_{n-1})d\ \mathrm{mod} \ b, \\
 *    c_n & = \lfloor (e_0 x_n + e_1 x_{n-1} + \cdots + e_k x_{n-k} + c_{n-1} )/b \rfloor, \\
 *    u_n & = \sum_{i=1}^\infty x_{n+i-1} b^{-i}.
 * \f}
 * The resulting object can then be used in any function working on
 * `MRGLattice`s seamlessly.
 *
 * \code{.cpp}
 * template<typename Int>
 *   Int LCGMod(const Int& b, const NTL::vector<Int>& e){
 *     Int m(0);
 *     for(int i = 0; i <= e.length(); i++) {
 *       m += e[i] * NTL::power(b, i);
 *     }
 *     return m;
 *   }
 *
 * template<typename Int>
 *   NTL::vector<Int> LCGCoeff(const Int& b, const NTL::vector<Int>& e){
 *     Int mult = LCGMod(b,e);
 *     std::cout << b << "\n";
 *     Int a = NTL::InvMod(b, mult);
 *     NTL::vector<Int> coeff;
 *     coeff.SetLength(2);
 *     coeff[1] = a;
 *     return coeff;
 *   }
 *
 * template<typename Int, typename Dbl>
 *   MWCLattice<Int, Dbl>::MWCLattice(const Int & b, const IntVec & e, int k):
 *     MRGLattice<Int, Dbl>(LCGMod(b, e), LCGCoeff(b,e), 1, 1, FULL)
 * {
 *   m_MWCmod = b;
 *   m_MWCorder = k;
 *   m_eCoef.SetLength(k+1);
 *   for (int i = 0; i < k+1; i++)
 *     m_eCoef[i] = e[i];
 * }
 * \endcode
 *
 * The other class to store MRG generators is the `LatMRG::MRGComponent` class.
 * Just like `MRGLattice`, this class stores the components of a MRG generator,
 * but it cannot store a lattice basis. This is useful when you want to avoid
 * having to store a heavy object only for generators componenets. This class
 * also bundles a few utility function that can, for example, check if the
 * components stored are that of a full period MRG.
 *
 * \subsection classes_list_tests Testing and Reducing Lattices
 *
 * Most of the reduction functions available in LatMRG come from the Lattice Tester
 * library. By using this library, it is possible to
 * - Compute the dual of an arbitrary basis
 * - Perform BKZ, LLL and pairwise reduction of a lattice
 * - Find the shortest non-zero vector in a lattice
 * - Normalize the length of a short lattice vector
 *
 * LatMRG mainly implements two things, buiding up on Lattice Tester
 * - Projections sets, in a way that is relevant to testing a random number generator
 * - Figures of Merit computations based on the shortest vector length or on the
 *   spectral test.
 *
 * `LatMRG::Projections` is the class representing projections. It can be
 * considered as a set \f$\mathcal{I}\f$ of sets of indices and can be iterated
 * over to obtain those sets of indices.
 *
 * The `test()` function can be found in `Test.h`. With the appropriate
 * initialization, this function can compute a wide variety of figures of merit
 * relevant to MRGs. Since this function is still a work in progress, its
 * documentation is not yet available.
 *
 * \todo Replace section numbers with appropriate links.
 *
 *   # Using the classes of LatMRG
 *
 *   The modules of LatMRG (excluding the executable programs) have
 * been classified in two sets: lower-level and intermediate-level. The
 * lower-level modules offer basic facilities for arithmetic operations and
 * conversions, with different representations, for basis vectors and
 * multipliers. They are described in the NTL documentation (see the URL
 * [http://shoup.net/ntl/doc/tour.html](http://shoup.net/ntl/doc/tour.html)).
 *
 *   The intermediate-level classes inheriting from the virtual class
 * <tt>IntLattice</tt> constructs lattice bases for different kinds of
 * generators or point sets. The currently implementing classes are
 * <tt>Rank1Lattice</tt>, <tt>KorobovLattice</tt> and <tt>MRGLattice</tt>.
 * <tt>IntLattice</tt> itself offers tools for manipulating lattice bases,
 * and generally does common operations on bases. The class <tt>Reducer</tt>
 * performs tests on these lattices, such as finding the shortest vector in a
 * lattice, and reducing a basis in the sense of Minkowski. Those classes are
 * described in the following chapters. The programs described in
 * \ref usage use those intermediate and
 * lower-level classes in their implementation, and so, provide examples of
 * how to use them.
 *
 *   # Lower-level modules and Changing the representation
 *
 *   As discussed in section \ref numbers_sec, the
 * multiplierâ€™s components can be implemented in the <tt>long</tt> or
 * <tt>ZZ</tt> representation, while the basis components can be in the
 * <tt>double</tt> or <tt>RR</tt> representation. To select the appropriate
 * representation (see modules <tt>Types</tt> where all the basic possible
 * types are selected), one should compile and link his programs with one of
 * the libraries <tt>liblatLLDD.a</tt>, <tt>liblatZZDD.a</tt> or
 * <tt>liblatZZRR.a</tt>. Generally speaking, the proper choice of
 * representation depends on the size of the modulus \f$m\f$. For example, if
 * \f$m\f$ is less than \f$2^{25}\f$, then the library <tt>liblatLLDD.a</tt>
 * should be appropriate. For most cases, the library <tt>liblatZZDD.a</tt>
 * will be satisfactory.
 *
 * */

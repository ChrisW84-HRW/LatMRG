// This file is part of LatMRG.
//
// Copyright (C) 2012-2023  The LatMRG authors, under the supervision
// of Pierre L'Ecuyer at Universit� de Montr�al.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef LATMRG__ENUMTYPES_H
#define LATMRG__ENUMTYPES_H
#include <string>
using namespace std;

#include "latticetester/EnumTypes.h"

namespace LatMRG {

/*
 * This static class contains enumeration types and global constants used in LatMRG
 *
 */

  /**
   * Types of generators handled by LatMRG.
   * `LCG`: linear congruential generator with a carry.<br>
   * `MRG`: multiple-recursive generator.<br>
   * `MMRG`: matrix multiple-recursive generator.<br>
   * `MWC`: multiply-with-carry generator. Usually transformed into an LCG. <br>
   * `COMBO`: a combined generator, with either MRG or MWC components. <br>
   */
  enum GenType { LCG, MRG, MMRG, MWC, COMBO };

  /**
   * Indicates whether to analyze the lattice generated by all possible states,
   * or a sub-lattice generated by the set of recurrent states or by a
   * sub-cycle of the generator.
   *
   * `FULL`: The complete lattice, generated by all possible initial states,
   * will be analyzed.<br>
   * `RECURRENT`: If the (combined) generator has
   * transient states, then the lattice analyzed will be the sub-lattice
   * generated by the set of recurrent states.<br>
   * `ORBIT`: The grid generated
   * by the (forward) orbit of a state of the (combined) generator is analyzed.
   * This state is specified as follows: on the following \f$J\f$ lines, the
   * initial state for each component must be given. This is an integer vector
   * with a number of components equal to the order of the component.<br>
   * `PRIMEPOWER`: In the case where some component is an MLCG whose modulus is
   * a power of a prime \f$p\f$, then the states visited over a single orbit
   * (sub-cycle) of that component generate a sub-lattice (when \f$a
   * \equiv1 \bmod p\f$) or belong to the union of \f$p-1\f$ sub-lattices
   * (otherwise). If `LatticeType` takes this value, and a component is a MLCG
   * (\f$k=1\f$), and if the modulus of that MLCG is given in the data file in
   * the form (b): \f$(x y z)\f$ with \f$z=0\f$ and \f$x\f$ prime, then what is
   * analyzed is one of those sub-lattices. This is done by dividing the
   * modulus by the appropriate power of \f$p\f$, as described in
   * \cite rLEC94e&thinsp;. For example, if \f$p=2\f$ and \f$a \mod8 = 5\f$,
   * then the modulus is divided by 4 as in \cite rFIS90a,
   * \cite rKNU81a&thinsp;.
   */
  enum LatticeType { FULL, RECURRENT, ORBIT, PRIMEPOWER };

  /**
   * Given an integer \f$r\f$, indicates what to do about the decomposition of
   * \f$r\f$ in its prime factors.
   *
   * `DECOMP`: means that the program will factorize \f$r\f$.<br>
   * <tt>DECOMP_WRITE</tt>: means that the program will factorize \f$r\f$ and
   * writes the factors in a file.<br>
   * <tt>DECOMP_READ</tt>: means that \f$r\f$ is already factorized, and the
   * factors will be read from a file.<br>
   * <tt>DECOMP_PRIME</tt>: means that \f$r\f$ is prime. No factorization will
   * be done.
   * <tt>NO_DECOMP</tt>: The program will not need a decomposition. Used when not
   * checking the period.
   */
  enum DecompType { DECOMP, DECOMP_WRITE, DECOMP_READ, DECOMP_PRIME, NO_DECOMP };


  /**
   * Indicates which type of conditions are imposed on the coefficients
   * \f$a_i\f$ of a recurrence.
   *
   * <tt>NO_COND</tt>: no condition is imposed on the coefficients.<br>
   * <tt>APP_FACT</tt>: the coefficients must satisfy the "approximate
   * factoring" condition \f$|a_i| (m\mod|a_i|) < m\f$. Congruential
   * generators are easier to implement under this condition
   * \cite rLEC90a&thinsp;.<br>
   * <tt>POWER_TWO</tt>: the coefficients must be sums or differences of powers
   * of 2.<br>
   * <tt>EQUAL_COEF</tt>: all the coefficients must be equal by groups: a first
   * group all equal to a first number, a second group all equal to a second
   * number, and so on. <br>
   * <tt>ZERO_COEF</tt>: all the coefficients must be equal to 0, except for a
   * select fews.
   */
  enum ImplemCond { NO_COND, APP_FACT, POWER_TWO, EQUAL_COEF, ZERO_COEF };

  /**
   * Indicates the search method used to find good multipliers \f$a_i\f$.
   *
   * `EXHAUST`: the search will be exhaustive over the chosen regions.<br>
   * `RANDOM`: the search will be random over the chosen regions.
   */
  enum SearchMethod { EXHAUST, RANDOM };

  /**
   * Indicates the type of lacunary projection used for MMRG:
   * - NONE: no lacunary projection
   * - SUBVECTOR: only the selected coordinates of each new random vector are kept
   * - ARBITRARYINDICES: only the selected indices are kept.
   */
  enum LacunaryType { NONE, SUBVECTOR, ARBITRARYINDICES };

  //============================================================================

  /**
   * The following are functions for printing the `enum` constants in this module.
   * Each function returns the value of the `enum` variable given as input as a string.
   */

  static std::string toStringGenType (GenType gen) {
	    switch (gen) {
	      case LCG:
	        return "LCG";
	      case MRG:
	        return "MRG";
	      case MWC:
	        return "MWC";
	      case MMRG:
	        return "MMRG";
	      case COMBO:
	        return "COMBO";
	      default:
	        return "***** GenType: UNDEFINED CASE ";
	     }
  }

  static std::string toStringLatticeType (LatticeType lat) {
      switch (lat) {
        case FULL:
          return "FULL";
        case RECURRENT:
          return "RECURRENT";
        case ORBIT:
          return "ORBIT";
        case PRIMEPOWER:
          return "PRIMEPOWER";
        default:
          return "***** LatticeType: UNDEFINED CASE ";
      } 
  }

  static std::string toStringDecompType (DecompType decomp) {
	    switch (decomp) {
	      case DECOMP:
	        return "DECOMP";
	      case DECOMP_WRITE:
	        return "DECOMP_WRITE";
	      case DECOMP_READ:
	        return "DECOMP_READ";
	      case DECOMP_PRIME:
	        return "DECOMP_PRIME";
	      case NO_DECOMP:
	        return "NO_DECOMP";
	      default:
	        return "***** DecompType: UNDEFINED CASE ";
	     }
   }
  
  static std::string toStringImplemCond (ImplemCond implem) {
	    switch (implem) {
	      case NO_COND:
	        return "NO_COND";
	      case APP_FACT:
	        return "APP_FACT";
	      case POWER_TWO:
	        return "POWER_TWO";
	      case EQUAL_COEF:
	        return "EQUAL_COEF";
	      case ZERO_COEF:
	        return "ZERO_COEF";
	      default:
	        return "***** ImplemCond: UNDEFINED CASE ";
	     }
  }
  
  static std::string toStringSearchMethod (SearchMethod searchm) {
	    switch (searchm) {
	      case EXHAUST:
	        return "EXHAUST";
	      case RANDOM:
	        return "RANDOM";
	      default:
	        return "***** SearchMethod: UNDEFINED CASE ";
	     }
  }
  
  static std::string toStringLacunaryType (LacunaryType lacunary) {
	    switch (lacunary) {
	      case NONE:
	        return "NONE";
	      case SUBVECTOR:
	        return "SUBVECTOR";
	      case ARBITRARYINDICES:
	        return "ARBITRARYINDICES";
	      default:
	        return "***** LacunaryType: UNDEFINED CASE ";
	     }
  }

};

#endif

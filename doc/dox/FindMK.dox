/**
 * \page FindMK FindMK
 *
 * This module contains a program to search for good modulus for MRGs. Given a
 * specific order, this program will search for modulus that are of one of two
 * forms :
 *   - Modulus that are smaller than a particular power of 2
 *   - Modulus that are in a specific interval
 *
 * In the first case, the program will search for \f$m\f$ prime such that
 * \f$m < 2^e\f$ and for which \f$r = (m^k-1)/(m-1)\f$ is also prime. We may
 * also require that \f$(m-1)/2\f$ be prime.
 *
 * In the second case, the program will search for all prime integers in a given
 * interval such that \f$ 2^e + c_1 \leq m \leq 2^e + c2\f$. It is also possible
 * to require to have \f$(m-1)/2\f$ be prime.
 *
 * In both cases, it is possible to ask to program to factorize \f$m-1\f$. This
 * factorization will then be printed in a file with the extension `.fac`.
 * This program uses the class LatMRG::Primes to perform its computations, and
 * this class uses LatticeTester::IntFactor.
 * \todo Why safe?
 *
 * This program is called `FindMK`. The program reads the search parameters
 * from a file. This data file must have
 * the extension `.dat`. To run the program, a combination of types and the name
 * of the data file must be given without extension on the command line, and the
 * results will be written in a file of the same name but with extension `.res`.
 * For example, if the data file is called `find.dat`, then the program is ran
 * by calling
 *
 *      FindMK <I,Z> find
 *
 * and the results will be written in file `find.res`.
 *
 * The data file must have the following format:
 *
 *      power
 *      k
 *      e
 *      c1 [c2]
 *      safe
 *      facto
 *
 * <center>
 * **Data file format for `FindMK`**
 * </center>
 *
 * The file must contain the following parameters in that order:
 *
 * <dl>
 * <dt>
 * `power` :
 * </dt>
 * <dd>
 * `<bool>` if power is `true`, the program will search for prime integers
 * smaller than \f$2^e\f$, otherwise the program will search in an interval.
 * </dd>
 * <dt>
 * `k` :
 * </dt>
 * <dd>
 * `<int>` the order of the MRG that you search an `m` for. Note that `k` has to
 * be odd because there are no prime `r` for `k` even.
 * </dd>
 * <dt> `e` :</dt>
 * <dd>
 * `<int>` the `e` for which the program will search around \f$2^e\f$.
 * </dd>
 * <dt> `c1 [c2]` :</dt>
 * <dd>
 * `<int> <int>` if power is `false`, the program will use \f$c_1\f$ and \f$c_2\f$
 * limit the research interval. If power is `true`, the program will make
 * computations until it has found \f$c_1\f$ primes meeting the constraints.
 * </dd>
 * <dt> `safe` :</dt>
 * <dd>
 * `<bool>` if `true`, only \f$m\f$ such that \f$(m-1)/2\f$ is prime are considered.
 * </dd>
 * <dt> `facto` :</dt>
 * <dd>
 * `<bool>` if `true`, the program will factorize \f$m-1\f$. It is recommended
 * to set this option to `false`, especially if `safe` is `true`.
 * </dd>
 * </dl>
 */
